# EXPLOIT DEVELOPMENT - N00B TO PRO

First of all to create an exploit from a executable file we need to analyze it

We can analyze any file using two methods
	
	- Static Analysis
	- Dynamic Analysis

## STATIC ANALYSIS

Static program analysis is the analysis of computer software that is performed without actually executing programs

Static Analysis is nothing but analysing static data from a file

Information which can be obtained from Static Analysis are,

	- Metadata
	- Header Tags
	- Function Names
	- String Values
	- etc..

Commonly used tools for Static Analysis in Linux are,

	- strings
	- readelf
	- objdump
	- file


## DYNAMIC ANALYSIS

Dynamic program analysis is the analysis of computer software that is performed by executing programs on a real or virtual processor

So to analyze the behaviour of the executable file in memeory and environment, we need Debuggers to monitor the file

Commonly used Debuggers are,

	- GDB
	- GDB-PEDA
	- IDA Pro
	- Immunity Debugger
	- OllyDbg
	- Hopper

## INTO THE "MEMORY"

## RAM

RAM - Random Access Memory

RAM is a  "VOLATILE" memory

RAM loses all of its data when the system power goes off in a "decaying" manner





## STACK

What is stack ?

Stack is a part of memory which used "Linear" data structure which follows LIFO (Last In First Out) / FILO (First In Last Out) order

A stack is a memory segment of computer's memory which stores temporary variables created by a function. In stack, variables are declared, stored and initialized during runtime

It is a temporary storage memory. When the computing task is complete, the memory of the variable will be automatically erased. The stack section mostly contains methods, local variable, and reference variables

Remember that stack is always "VOLATILE"

	- Stack access "Local Variables"
	- Stack variables "cannot be resized"
	- Stack memory is allocated in "Linear Order"
	- Stack need not to deallocate variables
	- Stack allocation and deallocation is done by "Compiler"

## HEAP

What is heap ?

The heap is a memory segment used by programming languages to store global variables

By default, all global variable are stored in heap memory space

It supports Dynamic memory allocation

The heap is not managed automatically for you and is not as tightly managed by the CPU

It is more like a free-floating region of memory

Garbage collection runs on the heap memory to free the memory used by the object

Heap method also used in the "Priority Queue"

	- Heap access "Global Variables"
	- Heap variables can be "Resized"
	- Heap memory is allocated in "Random Order"
	- Heap should perform deallocation
	- Heap allocation and deallocation is coded by "Programmer"

## REGISTERS

Registers are memory storage which is fabricated inside processors designed for specific purposes

Registers can also be viewed as "hardcoded variables" in the memory

## CACHE

Cache is like a secondary data storage which is used to "quickly" access data from the memory

Cache acts like a "buffer" between processor and primary memory to fetch the data ASAP

Caches can have many levels(L1,L2,L3..so on depends on the need of processor)

Executable code segments are copied into "Instruction Cache"

Frequently accessed pages of memory are stored in "Translation Lookaside Buffer (TLB) Cache" which reduces the time for "Virtual-to-Physical Memory Translation Process"

TLBs are flushed during context switches

Kernel TLBs should not be flushed to avoid a performance hit

	NOTE:
	- CPU access RAM little bit slow when compared with Processor Registers and L1 & L2 Cache











