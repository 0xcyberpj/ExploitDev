# INTRO TO BASIC ASM STRUCTURE

So whenever a source code is compiled, it is converted into object files so that i can be ran by ASM

To create an exploit we need to know about the basic structure of an object file

## OBJECT FILES

An object code is the representation of the source code in "binary format"

An object file can contain many data like

	- The actual binary program data
	- Symbol table
	- Relocation information
	- Other elements & etc..

Runtime operations and Symbol Resolutions are performed by "loader and linker" from an object file

### Linker: 
Responsible for resolving the location of wanted functions from the system library which are needed by the object file

It has the primary responsibilty of symbol resolution, taking the symbolic name of a function and linking it to its actual location

	Example:
		When printf() is being called
		Linker is responsible for locating the memory address of that function from a system library 
		Then populating a writable area in memory with the address inside the process

### Loader:
Loader is used to load an object file into memory at the wanted load addressing as well as to map various segments

Loaders are responsible for loading a program from disk or anysecondary storage into memory

Multiple segments are mapped and created in memory during program/binary runtime

The primary segments are the code segment, stack segment, data segment, heap, and Block Started by Symbol (BSS)

## CODE SEGMENT

The code segment (CS), as with the data segment and BSS segment, is of fixed size

Space/Memory size "cannot be allocated" into these segments without the potential for affecting the proper functionality of the program

The code segment is set up with "read and execute permissions"

The "write permission is disabled" because it contains the program's instructions as interpreted by the compiler

## DATA SEGMENT

The data segment (DS) contains "initialized global variables"

Eg: 
```
char Aiden[6]="Monish";
```

These are variables that were defined by the "programmer"

Segment registers DS, ES, FS, and GS can all map to different areas within memory

## BLOCK STARTED BY SYMBOL (BSS)

BSS contains "uninitialized global variables"

Eg: 
```
char Aiden[6];
```

Any variable with a value of zero upon runtime may reside in the BSS segment

Some compilers will not store these uninitialized variables in the BSS segment if it is determined that they are blocks of dead code that are unused

## STACK SEGMENT

Refer more about [Stack](#)
The stack segment is leveraged when function calls are made

The state of the process before a function is called is pushed onto the stack through a series of short operations known as the procedure "PROLOGUE"

Stack growth is done by nested function calls and more instructions

Each function gets its own memory frame in Stack

The stack often holds finite memory allocations associated with function calls, as well as arguments relative to a called function

Many functions return values back to the caller through the use of the EAX/RAX register, as well as other registers and memory locations

## HEAP SEGMENT

Refer about [Heap](#)

Applications performing large memory allocations to hold user data or run feature-rich content heavily utilize the heap

The heap is designed to border a large, unused memory segment to allow it to grow without interfering with other memory segments

### NOTE

Stack and Heap , both grows toward each other

But they are far way , because we need to ensure that Stack and Heap does not collide

Stack starts from higher memory and grow towards lower memory

Heap starts from lower memory and grow towards higher memory

Stack always used two pointers

	- Stack Pointer (SP)
	- Base Pointer (BP)

Stack Pointer (SP) points the top of the current stack frame

Base Pointer (BP) is used as a reference pointer to access all the local variables and arguments of the stack frame

CPU access all of the data used to process from the stack frame using BP registers

-----

## CALLING CONVENTIONS

Calling conventions are used to pass data to the called functions or retrieve data from the function return

More about [Calling Convention](https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions)

Commonly used calling conventions are,

	- cdecl
	- stdcall

### CDECL

It is common in C programs

Parameters or arguments are passed to "Called function" in "right to left" order on the stack

"Calling function" is responsible for tearing down the stack

EAX register is used to return values to the caller

Procedure epilogue data is automatically added to the program during compile time to handle the tearing down of the stack
	
### STDCALL

Similar like cdecl, commonly used in C programs

Parameters or arguments are passed to "Called function" in "right to left" order on the stack

"Called function" is responsible for tearing down the stack when the function is completed

EAX register is again used to return values from the called function back to the caller


Other commonly used calling functions are,

	- syscall
	- fastcall
	- optlink and so on..

-----

## RELOCATION

Update!!

## NAME MANGLING

Update!!

-----

## EXECUTABLE AND LINKING FORMAT (ELF)

ELF is an object file format used by many UNIX OSs to support "dynamic linking", "symbol resolution", and many other functions

ELF file contains a set of sections used by the linker where the object file contains

	-machine code of the executable program
	-symbols that need to be imported
	-functions that can be exported
	-debugging information
	-relocation information
	-header file

ELF file can be mapped directly into memory at runtime

Allows for relative addressing to remain while changing the load address

### RELOCATABLE ELF 

Relocatable ELF files contain multiple sections, such as object code, data, symbols having or needing resolution, a magic number, and various other sections

These sections are contained within the ELF header file

A relocatable file allows for the relative address of a mapped section or symbol to be maintained, while modifying the base address in the event there may be a conflict

	Example:
	if the relative address of a function called
	get_star() is 0x1000 and it was expecting to be mapped to the base address 0x02000000, the absolute address in that instance would be 0x02001000. However, if the file is in relocatable format, the base address could be relocated to a new base address, such as 0x08040000, resulting in the absolute address of 0x02012000(random)

### EXECUTABLE ELF

Executable ELF files are relatively close to the format of relocatable ELF files

The primary difference is the capability for an executable ELF file to be mapped directly into memory upon execution which is not being relocated

Executable ELF files have been optimized by including only the necessary sections, including read-only code, data, BSS, virtual addressing information, and some other relevant information

-----

## SHARED OBJECTS

A shared object is simply a library of functions available to developers which can be shared by programs on runtime

A dynamically compiled program relies on system libraries contained on a target system

These libraries are loaded into a program during startup, and the function names within them are dynamically
resolved as required

An ELF shared object file contains the elements of both relocatable files and executable files

It contains the program header file contained in an ELF executable file, loadable sections, and the additional linking information contained in relocatable files

----

## PROCEDURE LINKAGE TABLE (PLT)

Procedure Linkage Table(PLT) is a "read-only" section

It is responsible for calling the dynamic linker during and after the program runtime to resolve the addresses of the requested functions

During compilation we cannot mention these addresses because the function addresses of each system is unknown and shared object is also unavailable

So,PLT plays a vital role in resolving these function addresses during runtime

PLT table is much larger than the GOT table

Each program/binary has its own PLT table which is useful to itself only

When symbol resolution is requested, the request is made to the PLT by the calling function, and the address of the GOT is pushed into a processor register

This is how shared library functions are called via binaries

-----

## GLOBAL OFFSET TABLE (GOT)

Global Offset Table(GOT) is popped by a dynamic linker during programming runtime

Dynamic linker obtains the absolute addresses of requested functions and updates the GOT as requested

Files do not need to be relocatable because the GOT takes requests for locations from the Procedure Linkage Table
(PLT)

Many functions will not be resolved at runtime and get resolved only on the first call to the requested
function

This is a process known as "lazy linking", which saves on resources









